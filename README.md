# FullSourceBootstrapFromGit
Bootstrapping GNU/Linux x86 userland just from text-file sources inside Git repositories

## Introduction

Several projects try to provide [bootstrappable builds](https://bootstrappable.org/) for GNU/Linux userland.

Most notable are the [stage0-posix](https://github.com/oriansj/stage0-posix) and [live-bootstrap](https://github.com/fosslinux/live-bootstrap)
projects.

This project builds on top of these projects, yet has slightly different objectives: It should be possible to run/test
the various parts individually (both on own machine and in CI systems), and the used sources should be likely to being archived and easy to review.

It tries to follow the Guix bootstrap process, with minor deviations where better tooling is helpful.
([Relevant](https://guix.gnu.org/manual/en/html_node/Reduced-Binary-Seed-Bootstrap.html)
[dependency](https://www.gnu.org/software/mes/manual/html_node/The-Mes-Bootstrap-Process.html)
[charts](https://bootstrappable.org/projects/mes.html)).

### Overview

Bootstrapping happens in parts. As a rule of thumb, each part should run no longer than 30 minutes (on GitHub's CI runner). To run a part by GitHub's CI
runner, commit it into a branch whose name starts with the part name. When pushing to a branch on the root repository that matches the part name,
the part's artifacts (used by subsequent parts) are rebuilt as well. By definition, `part00`'s output tarball consists of the two `stage0-posix` binary seeds.

Each part starts by retrieving shallow clones of [all required git repositories](./git-repos.sh). Then, a script is run to prepare the part's input tarball.
All files in the input tarball need to either come from the input repositories, from this repository, or are generated by the script.
The script should only include trivial tasks (like copying files, renaming, symlinking, or running patch or sed) that theoretically could be performed manually.
(So no regeneration of grammars or running autoconf). Afterwards, the input tarball is checked against some rules: It may only contain directories
(mode 755), relative symlinks (absolute ones can be surprising when inspecting the tarball from outside the chroot), and UTF-8 encoded text files
(mode 644). There is a whitelist of allowed codepoints so that the text files should not contain too surprising things.
After that, the output tarballs of the depending parts are extracted on top of the input tarball. In the resulting
directory, one single command is executed inside a chroot (with fixed umask and environment and in its own
network namespace). Once the bootstrap is finished, the contents of <tt>/opt/part<i>nn</i>/</tt> is packaged
into the output tarball (including the whole path).

### Restrictions lifted from `live-bootstrap`'s restrictions

- The kernel is out of scope. This is all about GNU/Linux **userland**.
- Only chroot mode is supported, no qemu mode - not needed as the kernel is out of scope
- Pregenerated text files are not strictly forbidden. Pregenerated build scripts are no problem at all, and for pregenerated source code a justification
  should be made how easy it is to regenerate it at this stage of the bootstrap, and how hard it is to manually review the generated code vs. review the
  additional code that needs to get introduced into the bootstrap. [While developing, when in doubt, leave the pregenerated file]. In case the pregenerated
  files are missing from the source repositories, they have to be added to this repository instead.
- Bashisms are explicitly allowed. We are bootstrapping a GNU/Linux system (which includes bash quite early), and some bashisms (like brace expansions or
  associative arrays) are really useful for creating readable and concise scripts.
- We do not care whethe software is reproducible at this stage. If bootstrapping software is not reproducible, that should not matter,
  as it should eventually be used to build reproducible software anyway - and that software can then be checked against other builds
  (e.g. Debian's or Guix's). Of course, if the software is already reproducible, we can do hash checks or similar to enforce/verify it.


### Restrictions added to `live-bootstrap`'s restrictions

- It is split into parts, and the only way that files can propagate between parts is through the output tarballs (which are archived).
- No part of the bootstrap should be too slow to be testable even on weaker hardware (on my machine, part01 which takes 20 minutes on GitHub's runner,
  takes about 90 minutes. But that is still acceptable and you could always offload the work to CI).
- All files (except those in this repo) are from git repositories that have been archived by [Software Heritage](https://softwareheritage.org).
  Exception are files that are prepared by the part's script. But only simple modifications (sed, patch) are allowed here, no autotools etc.
- File types are restricted, and text files' characters need to be whitelisted.
- There are **no** gzipped tarballs in the inputs, all files are preextracted before the part starts.
- Network access during build is prohibited: Our early libcs do not even support the `socket` syscall, and additionally the parts are run in a
  separate network namespace.

## Progress

### Part 01

Part01 mostly stage0-posix project to build stage0-posix, mescc-tools, mescc-tools-extra, and M2-Planet.

Then it builds mes, mescc and an initial version of tcc 0.96 (Which takes the majority of the build time).

Although probably not utilized in the later stages, mes and mescc are still included in the output binaries.

Artifacts are [available here](https://github.com/schierlm/FullSourceBootstrapFromGit/releases/tag/part01-artifacts).

### Part 02

Part02 continues building a more powerful tcc 0.96, make 3.80, coreutils 5.0 and (noninteractive) bash 2.05b.

[This part is unfinished and may build more software in the future.]

Artifacts are [available here](https://github.com/schierlm/FullSourceBootstrapFromGit/releases/tag/part02-artifacts).
